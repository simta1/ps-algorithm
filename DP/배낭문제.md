[카테고리](/README.md)
# 배낭 문제(Knapsack Problem)
## Fractional Knapsack Problem
__시간복잡도__ $O(N \log{N})$   
__백준문제__ [How to Eat at a Buffet](https://www.acmicpc.net/problem/15407)   
그리디하게 무게당 가치가 가장 큰 것부터 사용하여 해결   

## 0-1 Knapsack Problem
__시간복잡도__ $O(NW)$   
__백준문제__ [평범한 배낭](https://www.acmicpc.net/problem/12865)   
```cpp
template <typename value_t, typename sum_t> // sum_t는 max(value) * n을 저장할 수 있는 타입
sum_t knapsack01(const vector<pair<int, value_t> > &bag, int maxWeight, sum_t justForValueSumType) {
    vector<sum_t> dp(maxWeight + 1); // dp[i] : i이하의 무게로 만들 수 있는 최대 가치
    for (auto &[w, v] : bag) {
        for (int i = maxWeight; i >= w; i--) dp[i] = max(dp[i], dp[i - w] + v);
    }
    return dp.back();
}
```
for문 방향 `i--`로 해야 됨   
`for (int i = w; i <= maxWeight; i++) dp[i] = max(dp[i], dp[i - w] + v);`로 계산할 경우 뒤쪽 언소들에는 v가 여러번 더해지게 되는데 0-1 Knapsack에서는 각 물건을 한 번만 쓸 수 있으므로 제대로 계산하려면 `i--`방향으로 계산해야 함

## Unbounded Knapsack Problem
__시간복잡도__ $O(NW)$   
__백준문제__ [사탕 가게](https://www.acmicpc.net/problem/4781), [카드 구매하기](https://www.acmicpc.net/problem/11052)   
```cpp
template <typename value_t, typename sum_t> // sum_t는 max(value) * n을 저장할 수 있는 타입
sum_t knapsackUnbounded(const vector<pair<int, value_t> > &bag, int maxWeight, sum_t justForValueSumType) {
    vector<sum_t> dp(maxWeight + 1); // dp[i] : i이하의 무게로 만들 수 있는 최대 가치
    for (auto &[w, v] : bag) {
        for (int i = w; i <= maxWeight; i++) dp[i] = max(dp[i], dp[i - w] + v);
    }
    return dp.back();
}
```
for문 방향 `i++`로 해야 됨   
0-1 knapsack `i--`방향이었던 것과는 다르게 `i++` 방향으로 하면 뒤쪽 언소들에 v가 여러번 더해지게 되므로 unbounded Knapsack의 정의에 맞게 계산됨   

## Bounded Knapsack Problem (binary splitting)
__시간복잡도__ $O(NW)$   
__백준문제__ [평범한 배낭 2](https://www.acmicpc.net/problem/12920)   
```cpp
template <typename value_t, typename sum_t> // sum_t는 max(value) * max(cnt) * n을 저장할 수 있는 타입
int knapsackBounded(const vector<tuple<int, value_t, int> > &bagBounded, int maxWeight, sum_t justForValueSumType) {
    vector<pair<int, sum_t> > bag;
    for (auto [w, v, cnt] : bagBounded) { // 무게 w, 가치 v의 물건이 cnt개 있음
        while (cnt) {
            int highHalf = cnt + 1 >> 1;
            bag.emplace_back(w * highHalf, v * highHalf);
            cnt -= highHalf;
        }
    }
    return knapsack01(bag, maxWeight, justForValueSumType);
}
```
0-1 knapsack 문제로 변환해서 해결 가능

## Bitset Knapsack
아이템 중 일부를 골라 특정 무게를 만드는 게 가능한지 판별하는 게 목적인 경우 bitset으로 최적화 가능   
__시간복잡도__ $O\left(\dfrac{NW}{64}\right)$   
__백준문제__ [양팔저울](https://www.acmicpc.net/problem/2629), [저울](https://www.acmicpc.net/problem/2437), [Bad Packing](https://www.acmicpc.net/problem/21135), [Kitchen Cable Chaos](https://www.acmicpc.net/problem/16072)   
```cpp
template <int SUM> // sum_{abs(v[i])} <= SUM
void f(const vector<int> &v) { // v의 원소들 중 일부를 골라 만들 수 있는 합들 전부 계산
    bitset<SUM + 1> dp;
    dp[0] = 1;
    for (auto e : v) dp |= dp << e;
    for (int i = 0; i < dp.size(); i++) if (dp[i]) cout << i << " ";
}

template <int SUM> // sum_{abs(v[i])} <= SUM
void f(const vector<int> &v) { // v의 원소들에 + 또는 - 부호를 붙일 수 있는 경우
    const int offset = SUM;
    bitset<2 * SUM + 1> dp;
    dp[offset] = 1;
    for (auto e : v) dp |= (dp << e) | (dp >> e);
    for (int i = 0; i < dp.size(); i++) if (dp[i]) cout << i - offset << " ";
}
```

## $O(W \sqrt{W})$ Bitset Knapsack
가치가 같은 아이템들끼리 묶으면 $O(\sqrt{W})$종류의 가치만 존재하므로 ($\because$ [Harmonic lemma](/수학/Harmonic%20Lemma.md)) binary splitting과 함께 사용하면 시간복잡도에서 $N \rightarrow \sqrt{W}$로 대체 가능   
__시간복잡도__ $O\left(\dfrac{W \sqrt{W}}{64}\right)$   
__백준문제__ [Fair Distribution](https://www.acmicpc.net/problem/31756)   
<!-- [Keyboard](https://www.acmicpc.net/problem/21844), [Gastronomic Event](https://www.acmicpc.net/problem/25063) -->
```cpp
template <int SUM> // sum_{abs(v[i])} <= SUM
void f(const vector<int> &v) { // v의 원소들 중 일부를 골라 만들 수 있는 합들 전부 계산
    int mx = *max_element(v.begin(), v.end());
    vector<int> cnt(mx + 1);
    for (auto e : v) ++cnt[e];

    bitset<SUM + 1> dp;
    dp[0] = 1;
    
    for (int e = 0; e <= mx; e++) { // cnt[e]>0인 경우는 O(sqrt(SUM))번 등장
        while (cnt[e]) {
            int highHalf = cnt[e] + 1 >> 1;
            cnt[e] -= highHalf;
            dp |= dp << (e * highHalf);
        }
    }

    for (int i = 0; i < dp.size(); i++) if (dp[i]) cout << i << " ";
}
```

### 참고링크
https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/   
https://godls036.tistory.com/7   
https://egod1537.tistory.com/entry/Bounded-Knapsack-Problem%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0   