[카테고리](/README.md)
### 배낭 문제(Knapsack Problem)
```cpp
template <typename T>
T knapsack(const vector<pair<int, T> > &bag, int maxWeight) {
    vector<T> dp(maxWeight + 1); // dp[i] : i이하의 무게로 만들 수 있는 최대 가치
    for (auto &[w, v] : bag) {
        for (int i = maxWeight; i >= w; i--) dp[i] = max(dp[i], dp[i - w] + v);
    }
    return dp.back();
}
```
### 시간복잡도 
$O(NW)$   

### 구현 주의사항
for문 방향 `i--`로 해야 됨   
`for (int i = w; i <= maxWeight; i++) dp[i] = max(dp[i], dp[i - w] + v);`로 계산할 경우 뒤쪽 언소들에는 v가 여러번 더해지게 됨.   
중복 갱신 없이 제대로 계산하려면 `i--`방향으로 계산해야 함

각 물건을 최대 한 번 사용할 수 있기 때문에 `for (auto &[w, v] : bag)` 반복문이 `for (int i = maxWeight; i >= w; i--)`반복문보다 바깥에 와야 함   
같은 물건을 여러번 사용할 수 있는 문제의 예시로는 [카드 구매하기](https://www.acmicpc.net/problem/11052)가 있음   

### 문제
[평범한 배낭](https://www.acmicpc.net/problem/12865)   

### 다른코드
이렇게도 풀 수 있다   
좀 더 직관적인 코드인 듯   
```cpp
template <typename T>
T knapsack(const vector<pair<int, T> > &bag, int maxWeight) {
    vector<T> dp(maxWeight + 1); // dp[i] : 정확히 i만큼의 무게로 만들 수 있는 최대 가치, 정확히 i의 무게가 불가능하다면 0

    for (auto &[w, v] : bag) if (w <= maxWeight) { // dp[w] = max(dp[w], v)에서 outOfBounds 아니려면 w <= maxWeight인지 확인 필요
        for (int i = maxWeight; i > w; i--) if (dp[i - w]) {
            dp[i] = max(dp[i], dp[i - w] + v);
        }
        dp[w] = max(dp[w], v);
    }

    return *max_element(dp.begin(), dp.end());
}
```