[카테고리](/README.md)
## 3D Convex Hull
### [3D 기하학 헤더](/기하학/3D%20기하.md)
<details>
<summary>Point, Cross Product</summary>

```cpp
template <typename T>
struct Point3D {
    T x, y, z;

    Point3D() = default;
    Point3D(T x, T y, T z) : x(x), y(y), z(z) {}
    template <typename U> Point3D(const Point3D<U> &other) : x(static_cast<T>(other.x)), y(static_cast<T>(other.y)), z(static_cast<T>(other.z)) {}

    Point3D operator-(const Point3D &other) const { return {x - other.x, y - other.y, z - other.z}; }
};

template <typename T>
Point3D<T> crossProduct(const Point3D<T> &p1, const Point3D<T> &p2) {
    return {p1.y * p2.z - p1.z * p2.y, p1.z * p2.x - p1.x * p2.z, p1.x * p2.y - p1.y * p2.x};
}
```
</details>

### naive $O(N^4)$ (4개 이상의 점이 coplanar인 경우가 없다고 가정한 코드)
```cpp
template <typename T>
bool isExtreme(const vector<Point3D<T> > &points, const Point3D<T> &p1, const Point3D<T> &p2, const Point3D<T> &p3) {
    auto [a, b, c] = crossProduct(p2 - p1, p3 - p1); // ax + by + cz + d = 0
    if (!a && !b && !c) return false; // collinear
    auto d = -(a * p1.x + b * p1.y + c * p1.z);

    int cntPos = 0, cntNeg = 0;
    for (auto [x, y, z] : points) {
        if (a * x + b * y + c * z + d > 0) ++cntPos;
        if (a * x + b * y + c * z + d < 0) ++cntNeg;
    }
    return cntPos == 0 || cntNeg == 0;
}

template <typename T>
vector<tuple<int, int, int> > getConvexHullFaceIdxes(const vector<Point3D<T> > &points) {
    vector<tuple<int, int, int> > res;
    int n = points.size();
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            for (int k = j + 1; k < n; ++k) {
                if (isExtreme(points, points[i], points[j], points[k])) res.emplace_back(i, j, k);
            }
        }
    }
    return res;
}
```
### incremental $O(N^2)$
```cpp
```
### divide and conquer $O(N \log{N})$
```cpp
```
### 시간복잡도
$O(N^4)$ - 아직 naive밖에 구현 안 해둠   

### 구현 주의사항
naive구현할 때 `isExtreme()`에서 cntPos와 cntNeg 계산하는 중 ax+by+cz+d=0일 수 있음에 주의해야 된다.   
```cpp
    int cntPos = 0, cntNeg = 0;
    for (auto [x, y, z] : points) {
        // 잘못된 코드
        if (a * x + b * y + c * z + d > 0) ++cntPos;
        else ++cntNeg; // p1, p2, p3는 애초에 points배열에서 뽑은 점이기 때문에 point가 p1, p2, p3중 하나이면 ax+by+cz+d=0인 경우가 가능함, 0인 경우에 ++cntNeg되서 문제 생김

        // 맞는 코드
        if (a * x + b * y + c * z + d > 0) ++cntPos;
        if (a * x + b * y + c * z + d < 0) ++cntNeg;
    }
```

### 사용설명


### 문제
[Convex area](https://www.acmicpc.net/problem/7684) - O(N^4) naive   
[]()

### 참고링크
https://tildesites.bowdoin.edu/~ltoma/teaching/cs3250-CompGeom/spring17/Lectures/cg-hull3d.pdf   