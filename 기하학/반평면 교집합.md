[카테고리](/README.md)
## 반평면 교집합(HalfPlane Intersection)
### [기하학 헤더](/기하학/Geometry%20Header.md)
<details>
<summary>Point, Cross Product, CCW</summary>

```cpp
template <typename T>
struct Point {
    T x, y;

    Point() = default;
    Point(T x, T y) : x(x), y(y) {}
    template <typename U> Point(const Point<U> &other) : x(static_cast<T>(other.x)), y(static_cast<T>(other.y)) {}

    Point operator-(const Point &other) const { return {x - other.x, y - other.y}; }
};

template <typename T>
T crossProduct(const Point<T> &p1, const Point<T> &p2) {
    return (p1.x * p2.y - p2.x * p1.y);
}

template <typename T>
int ccw(const Point<T> &p1, const Point<T> &p2, const Point<T> &p3) { // -1 : 시계, 0 : 일직선, 1 : 반시계
    T cp = crossProduct(p2 - p1, p3 - p1);
    return (cp > 0) - (cp < 0);
}
```
</details>

### 반평면 교집합
```cpp
const ld eps = 1e-9; // epsilon

template <bool CCW>
struct HalfPlane {
    Point<ld> start, dir; // start점을 지나며 dir의 방향을 가지는 직선, 반평면은 dir을 CCW로 90도 회전한 방향에 위치(CCW=true이면 반시계이므로 dir기준 왼쪽)

    template <typename T>
    HalfPlane(Point<T> &s, Point<T> &e) : start(s), dir(e - s) {
        ld len = hypot(dir.x, dir.y);
        dir.x /= len;
        dir.y /= len;
    }

    void move(ld d) {
        if constexpr (CCW) { // dir 반시계 90도 법선 벡터 : (-dir.y, dir.x)
            start.x -= d * dir.y;
            start.y += d * dir.x;
        }
        else { // dir 시계 90도 법선 벡터 : (dir.y, -dir.x)
            start.x += d * dir.y;
            start.y -= d * dir.x;
        }
    }

    Point<ld> getPoint(ld k) const {
        return {start.x + k * dir.x, start.y + k * dir.y};
    }

    friend Point<ld> intersectionHH(const HalfPlane &a, const HalfPlane &b) {
        ld k = crossProduct(b.start - a.start, a.dir) / crossProduct(a.dir, b.dir);
        return b.getPoint(k);
    }

    bool include(const HalfPlane &a, const HalfPlane &b) { // a, b 교점이 반평면에 포함되는지
        Point point = intersectionHH(a, b);
        if constexpr (CCW) return crossProduct(dir, point - start) > eps;
        else return crossProduct(dir, point - start) < -eps;
    }
};

template <bool CCW>
vector<Point<ld> > HPI(vector<HalfPlane<CCW> > planes, ld d=0, bool sortedByAngle=false) { // 반평면들을 각각의 방향으로 d만큼 움직였을 때 교집합
    if (!sortedByAngle) {
        
    }

    if (d) for (auto &plane : planes) plane.move(d);

    deque<HalfPlane<CCW> > dq;
    for (auto &plane : planes) {
        while (dq.size() >= 2 && !plane.include(dq[dq.size() - 2], dq[dq.size() - 1])) dq.pop_back();
        while (dq.size() >= 2 && !plane.include(dq[0], dq[1])) dq.pop_front();
        if (dq.size() < 2 || dq[0].include(dq.back(), plane)) dq.push_back(plane);
    }
    
    vector<Point<ld> > res;
    if (dq.size() < 3) return res;
    for (int i = 0, j = dq.size() - 1; i < dq.size(); j = i++) {
        if (abs(crossProduct(dq[i].dir, dq[j].dir)) > eps) res.push_back(intersectionHH(dq[i], dq[j]));
    }
    return res;
}
```
### 시간복잡도
$O(N \log{N})$   

### 사용설명
TODO, 확인 필요)   
아마도 `HPI()`의 리턴값은 볼록 껍질임   

### 문제
[제주도](https://www.acmicpc.net/problem/3903)   
[2circles](https://www.acmicpc.net/problem/5255)   

### 참고링크
https://junh0.tistory.com/7   
https://infossm.github.io/blog/2019/09/17/Half-Plane-Intersection/   
https://cp-algorithms.com/geometry/halfplane-intersection.html   