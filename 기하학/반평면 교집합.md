[카테고리](/README.md)
## 반평면 교집합(HalfPlane Intersection)
```cpp
const ld eps = 1e-9; // epsilon

template <typename T>
struct Point {
    T x, y;

    Point() = default;
    Point(T x, T y) : x(x), y(y) {}
    template <typename U> Point(const Point<U> &other) : x(static_cast<T>(other.x)), y(static_cast<T>(other.y)) {}

    Point operator-(const Point &other) const { return {x - other.x, y - other.y}; }
};

template <typename T>
T crossProduct(const Point<T> &p1, const Point<T> &p2) {
    return (p1.x * p2.y - p2.x * p1.y);
}

template <typename T>
int ccw(const Point<T> &p1, const Point<T> &p2, const Point<T> &p3) { // -1 : 시계, 0 : 일직선, 1 : 반시계
    T cp = crossProduct(p2 - p1, p3 - p1);
    return (cp > 0) - (cp < 0);
}

struct HalfPlane {
    Point<ld> start, dir;

    template <typename T>
    HalfPlane(Point<T> &s, Point<T> &e) : start(s), dir(e - s) {
        ld len = hypot(dir.x, dir.y);
        dir.x /= len;
        dir.y /= len;
    }

    void move(ld d) {
        start.x -= d * dir.y; // dir 반시계 90도 법선 벡터 : (-dir.y, dir.x)
        start.y += d * dir.x;
    }

    Point<ld> getPoint(ld k) const {
        return {start.x + k * dir.x, start.y + k * dir.y};
    }

    Point<ld> intersection(const HalfPlane &a, const HalfPlane &b) {
        ld k = crossProduct(b.start - a.start, a.dir) / crossProduct(a.dir, b.dir);
        return b.getPoint(k);
    }

    bool include(const HalfPlane &a, const HalfPlane &b) { // check intersection of a,b is on left of line
        Point point = intersection(a, b);
        return crossProduct(dir, point - start) > eps;
    }
};

deque<HalfPlane> halfPlaneIntersection(vector<HalfPlane> planes, ld translateDist) { // 반평면들을 각각의 방향으로 translateDist만큼 움직인 뒤 교집합
    // 이미 정렬되어있으면 각도순 정렬은 안 해도 됨
    for (auto &plane : planes) plane.move(translateDist);

    deque<HalfPlane> dq;
    for (auto &plane : planes) {
        while (dq.size() >= 2 && !plane.include(dq[dq.size() - 2], dq[dq.size() - 1])) dq.pop_back();
        dq.push_back(plane);
    }

    while (dq.size() >= 3 && !dq.front().include(dq[dq.size() - 2], dq[dq.size() - 1])) dq.pop_back();
    while (dq.size() >= 3 && !dq.back().include(dq[0], dq[1])) dq.pop_front();
    
    return dq;
}
```
### 시간복잡도
$O(N \log{N})$   

### 사용설명


### 문제
[제주도](https://www.acmicpc.net/problem/3903)   

### 참고링크
https://cp-algorithms.com/geometry/halfplane-intersection.html   
https://junh0.tistory.com/7   