[카테고리](/README.md)
## 반평면 교집합(HalfPlane Intersection)
### [기하학 헤더](/기하학/Geometry%20Header.md)
<details>
<summary>Point, Cross Product, CCW</summary>

```cpp
template <typename T>
struct Point {
    T x, y;

    Point() = default;
    Point(T x, T y) : x(x), y(y) {}
    template <typename U> Point(const Point<U> &other) : x(static_cast<T>(other.x)), y(static_cast<T>(other.y)) {}

    Point operator-(const Point &other) const { return {x - other.x, y - other.y}; }
};

template <typename T>
T crossProduct(const Point<T> &p1, const Point<T> &p2) {
    return (p1.x * p2.y - p2.x * p1.y);
}

template <typename T>
int ccw(const Point<T> &p1, const Point<T> &p2, const Point<T> &p3) { // -1 : 시계, 0 : 일직선, 1 : 반시계
    T cp = crossProduct(p2 - p1, p3 - p1);
    return (cp > 0) - (cp < 0);
}
```
</details>

### 반평면 교집합
```cpp
const ld eps = 1e-9; // epsilon

template <bool isCCW>
struct HalfPlane {
    Point<ld> start, dir; // isCCW=tue일 때 반평면은 dir을 반시계 90도 회전한 방향(dir 왼쪽)에 위치

    template <typename T>
    HalfPlane(const Point<T> &s, const Point<T> &e) : start(s), dir(e - s) {
        ld len = hypot(dir.x, dir.y);
        dir.x /= len;
        dir.y /= len;
    }
    
    template <typename T>
    HalfPlane(T a, T b, T c) { // ax + by + c >= 0
        assert(a != 0 || b != 0);

        start = (a != 0 ? Point<ld>(-ld(c) / a, 0) : Point<ld>(0, -ld(c) / b));
        
        // ax + by + c = 0이면 a(x+a) + b(y+b) + c = ax+by+c+a^2+b^2>=0 이므로 (a, b)쪽이 반평면 방향이 되어야 함
        if constexpr (isCCW) dir = {b, -a};
        else dir = {-b, a};

        ld len = hypot(dir.x, dir.y);
        dir.x /= len;
        dir.y /= len;
    }

    void move(ld d) {
        if constexpr (isCCW) { // dir 반시계 90도 법선 벡터 : (-dir.y, dir.x)
            start.x -= d * dir.y;
            start.y += d * dir.x;
        }
        else { // dir 시계 90도 법선 벡터 : (dir.y, -dir.x)
            start.x += d * dir.y;
            start.y -= d * dir.x;
        }
    }

    Point<ld> getPoint(ld k) const {
        return {start.x + k * dir.x, start.y + k * dir.y};
    }

    friend Point<ld> intersectionHH(const HalfPlane &a, const HalfPlane &b) {
        ld k = crossProduct(b.start - a.start, a.dir) / crossProduct(a.dir, b.dir);
        return b.getPoint(k);
    }

    bool include(const HalfPlane &a, const HalfPlane &b) { // a, b의 교점이 반평면에 포함되는지
        Point point = intersectionHH(a, b);
        if constexpr (isCCW) return crossProduct(dir, point - start) > eps;
        else return crossProduct(dir, point - start) < -eps;
    }
};

template <bool isCCW>
vector<Point<ld> > HPI(vector<HalfPlane<isCCW> > planes, ld d=0, bool sortedByAngle=false) { // 반평면들을 각각 거리 d만큼 움직였을 때 교집합
    if (!sortedByAngle) {
        auto checkQuadrant = [](const HalfPlane<isCCW> &hp) -> bool {
            return hp.dir.y < 0 || (hp.dir.y == 0 && hp.dir.x < 0); // PI <= atan2(dir) < 2 * PI
        };        
        
        sort(planes.begin(), planes.end(), [&](const HalfPlane<isCCW> &a, const HalfPlane<isCCW> &b) {
            bool aq = checkQuadrant(a), bq = checkQuadrant(b);
            if constexpr (isCCW) return aq != bq ? aq < bq : crossProduct(a.dir, b.dir) > 0;
            else return aq != bq ? aq < bq : crossProduct(a.dir, b.dir) < 0;
        });
    }

    if (d) for (auto &plane : planes) plane.move(d);

    deque<HalfPlane<isCCW> > dq;
    for (auto &plane : planes) {
        while (dq.size() >= 2 && !plane.include(dq[dq.size() - 2], dq[dq.size() - 1])) dq.pop_back();
        while (dq.size() >= 2 && !plane.include(dq[0], dq[1])) dq.pop_front();
        if (dq.size() < 2 || dq[0].include(dq.back(), plane)) dq.push_back(plane);
    }
    
    vector<Point<ld> > res;
    if (dq.size() < 3) return res;
    for (int i = 0, j = dq.size() - 1; i < dq.size(); j = i++) {
        if (abs(crossProduct(dq[i].dir, dq[j].dir)) > eps) res.push_back(intersectionHH(dq[i], dq[j]));
    }
    return res; // 리턴값은 볼록 껍질 형태임, isCCW에 따라 볼록껍질 정렬방향 다름
}
```
<!-- TODO
    planes.size()==2이고 두 plane의 기울기가 같은 경우 교집합이 존재하지만 비어있는 배열이 리턴될듯.. 확인해봐야됨
 -->

### 시간복잡도
$O(N \log{N})$   

### 사용설명
move(ld d)의 구현을 위해 HalfPlane에서 Point의 자료형은 무조건 `Point<ld>`를 사용하도록 했음   

`hpi()`는 반평면 교집합에 해당하는 다각형의 각 꼭짓점들의 좌표를 한 방향으로 정렬해서 리턴   


`HalfPlane(T a, T b, T c)` 생성자 사용시 isCCW는 딱히 신경 쓸 필요없음   
`HalfPlane(Point<T> &s, Point<T> &e)` 생성자 사용할 때는 isCCW 방향 정확히 명시해줘야 함   

```cpp
vector<Point<T> > points(n);
for (auto &[x, y] : points) cin >> x >> y;

// 문제에서 입력으로 볼록다각형의 꼭짓점들이 반시계방향 순으로 주어지는 경우라면
vector<HalfPlane<true> > planes;
for (int i = 0, j = n - 1; i < n; j = i++) planes.emplace_back(points[j], points[i]); 

// 문제에서 입력으로 볼록다각형의 꼭짓점들이 시계방향 순으로 주어지는 경우라면
vector<HalfPlane<false> > planes;
for (int i = 0, j = n - 1; i < n; j = i++) planes.emplace_back(points[j], points[i]); 
```
### 문제
[제주도](https://www.acmicpc.net/problem/3903)   
[2circles](https://www.acmicpc.net/problem/5255)   

### 참고링크
https://junh0.tistory.com/7   
https://infossm.github.io/blog/2019/09/17/Half-Plane-Intersection/   
https://cp-algorithms.com/geometry/halfplane-intersection.html   