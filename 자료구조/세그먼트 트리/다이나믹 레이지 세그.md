[카테고리](/README.md)
# 세그 총집합. TODO
* [ ] 다이나믹 써서 좌표압축 쓸 필요 없게 만들기
* [ ] 포인터 쓰지 말고 인덱스 기반 구현으로 메모리 줄이기
* [ ] array doubling고려해서 미리 다이나믹 세그에서 쓸 노드 개수 reserve 할 수 있도록 하기
* [ ] 레이지 써서 rUpdate, rQuery 전부 지원
* [ ] updateChange, updateAdd 전부 지원
* [ ] findKth 추가
* [ ] Node, merge(Node, Node) 람다로 받아서 모든 세그 사용할 수 있도록 하기
* [ ] 길게 봐서 세그트리비츠까지 람다로 넣어구현할 수 있게 하면 좋을 듯 https://hyperbolic.tistory.com/3
* [ ] 자주쓰는 람다는 따로 코드 추가해두기 (덧셈 등등)
* [ ] 금광 세그용 Node, merge코드도 추가하면 좋을 듯


## Dynamic Lazy Segment Tree
```cpp
template <typename idx_t, typename T>
class DynamicSeg {
private:
    struct Node {
        T val;
        T lazy;
        int l, r;

        Node(T val) : val(val), lazy(0), l(0), r(0) {}
        Node() : Node(0) {} // 항등원
    };

    T merge(const T &a, const T &b) { return a + b; }

    vector<Node> tree;
    const int root = 1;
    const idx_t MAX_IDX;
    
    int newNode() { tree.push_back(Node()); return tree.size() - 1; }
    
    void propagate(int node, int s, int e) {
        if (!node) return; // tree[0].val은 항상 항등원으로 유지되어야 함
        
        if (!tree[node].lazy) return;

        tree[node].val += (e - s + 1) * tree[node].lazy;
        if (s != e) {
            if (!tree[node].l) tree[node].l = newNode();
            tree[tree[node].l].lazy += tree[node].lazy;
            if (!tree[node].r) tree[node].r = newNode();
            tree[tree[node].r].lazy += tree[node].lazy;
        }
        tree[node].lazy = 0;
    }

    bool haveOverlap(idx_t s, idx_t e, idx_t l, idx_t r) {
        return !(r < s || e < l);
    }

    void update(int node, idx_t s, idx_t e, idx_t l, idx_t r, T val, bool add) {
        // cout << "U(" << val << ") : tree[" << s << ":" << e << "]={" << tree[node].val << ", " << tree[node].lazy << "}, target: [" << l << ", " << r << "] \n";
        propagate(node, s, e);

        if (r < s || e < l) return;
        if (l <= s && e <= r) {
            tree[node].lazy = val;
            return;
        }

        idx_t m = s + e >> 1;
        if (haveOverlap(s, m, l, r)) {
            if(!tree[node].l) tree[node].l = newNode(); // propagate호출한 이후라서 s!=e라면 무조건 자식 만들어져있을거라 생각했지만 lazy=0이면 아니라서 확인해야됨
            update(tree[node].l, s, m, l, r, val, add);
        }
        if (haveOverlap(m + 1, e, l, r)) {
            if(!tree[node].r) tree[node].r = newNode();
            update(tree[node].r, m + 1, e, l, r, val, add);
        }
        tree[node].val += val * (min(e, r) - max(s, l) + 1);
    }

    T query(int node, idx_t s, idx_t e, idx_t l, idx_t r) {
        // cout << "Q : tree[" << s << ":" << e << "].val=" << tree[node].val << ", target: [" << l << ", " << r << "] \n";
        if (!node) return tree[0].val; // dummy
        propagate(node, s, e);
        if (r < s || e < l) return 0;
        if (l <= s && e <= r) return tree[node].val;

        idx_t m = s + e >> 1;
        T lq = query(tree[node].l, s, m, l, r);
        T rq = query(tree[node].r, m + 1, e, l, r);
        return merge(lq, rq);
    }

public:
    DynamicSeg(idx_t maxIdx) : MAX_IDX(maxIdx), tree(2) {} // tree[0] : dummy, tree[1] : root

    void reserve(int sz) { if (sz > tree.capacity()) tree.reserve(sz); } // array doubling 최소화
    
    void updateAdd(idx_t l, idx_t r, T val) { // 0 <= i <= MAX_IDX
        update(root, 0, MAX_IDX, l, r, val, 1);
    }

    void updateAdd(idx_t idx, T val) { // 0 <= i <= MAX_IDX
        update(root, 0, MAX_IDX, idx, idx, val, 1);
    }

    void updateChange(idx_t l, idx_t r, T val) { // 0 <= i <= MAX_IDX
        update(root, 0, MAX_IDX, l, r, val, 0); // TODO 아직 구현안함
    }

    void updateChange(idx_t idx, T val) { // 0 <= i <= MAX_IDX
        update(root, 0, MAX_IDX, idx, idx, val, 0); // TODO 아직 구현안함
    }

    T query(idx_t l, idx_t r) { // 0 <= l <= r <= MAX_IDX
        return query(root, 0, MAX_IDX, l, r);
    }

// findKth
private:
    idx_t findKthSmallest(int node, idx_t s, idx_t e, T k) {
        cout << "kth small:" << tree[node].val << " " << s << " " << e << " " << k << "\n";
        propagate(node, s, e);
        if (s == e) return s;
        
        idx_t m = s + e >> 1;
        propagate(tree[node].l, s, m);
        T lsz = tree[tree[node].l].val;
        if (lsz >= k) return findKthSmallest(tree[node].l, s, m, k);
        return findKthSmallest(tree[node].r, m + 1, e, k - lsz);
    }
    
    idx_t findKthLargest(int node, idx_t s, idx_t e, T k) {
        // cout << "kth large:" << tree[node].val << " " << s << " " << e << " " << k << "\n";
        propagate(node, s, e);
        if (s == e) return s;
        
        idx_t m = s + e >> 1;
        propagate(tree[node].r, m + 1, e);
        T rsz = tree[tree[node].r].val;
        if (rsz >= k) return findKthLargest(tree[node].r, m + 1, e, k);
        return findKthLargest(tree[node].l, s, m, k - rsz);
    }

public:
    idx_t findKthSmallest(int k) {
        assert (k >= 1);
        return k > tree[root].val ? -1 : findKthSmallest(root, 0, MAX_IDX, k);
    }

    idx_t findKthLargest(int k) {
        assert (k >= 1);
        return k > tree[root].val ? -1 : findKthLargest(root, 0, MAX_IDX, k);
    }
};
```
### 시간복잡도
range update $O(logN)$   
range query $O(logN)$   

### 공간복잡도
$O(QlogN)$   

### 구현 주의사항


### 사용설명
0 <= max_idx 내의 인덱스에 대해서 업데이트 가능   
array doubling 고려해서 reserve()해두고 사용하면 더 좋음   

### 문제
[일기예보](https://www.acmicpc.net/problem/14577) - 다이나믹 세그 / point update, range query / 세그이분탐색   

### 참고링크
https://nicotina04.tistory.com/265   