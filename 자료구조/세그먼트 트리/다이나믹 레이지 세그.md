[카테고리](/README.md)
<!-- TODO updateChange, updateAdd 추가해야됨 -->
## Dynamic Lazy Segment Tree
```cpp
template <typename idx_t, typename T>
class DynamicLazySeg {
private:
    struct Node {
        T val;
        T lazy;
        int l, r;

        Node(T val) : val(val), lazy(0), l(0), r(0) {}
        Node() : Node(0) {} // 항등원
    };

    T merge(const T &a, const T &b) { return a + b; }

    vector<Node> tree;
    const int root = 1;
    const idx_t MAX_IDX;
    
    int newNode() { tree.push_back(Node()); return tree.size() - 1; }
    
    void propagate(int node, int s, int e) {
        if (!node) return; // tree[0].val은 항상 항등원으로 유지되어야 함
        
        if (!tree[node].lazy) return;

        tree[node].val += (e - s + 1) * tree[node].lazy;
        if (s != e) {
            if (!tree[node].l) tree[node].l = newNode();
            tree[tree[node].l].lazy += tree[node].lazy;
            if (!tree[node].r) tree[node].r = newNode();
            tree[tree[node].r].lazy += tree[node].lazy;
        }
        tree[node].lazy = 0;
    }

    bool haveOverlap(idx_t s, idx_t e, idx_t l, idx_t r) {
        return !(r < s || e < l);
    }

    // 항상 haveOverlap()으로 확인된 구간만 들어옴, 구간이 하나도 겹치지 않는 경우는 애초에 없음
    void update(int node, idx_t s, idx_t e, idx_t l, idx_t r, T val, bool add) {
        if (l <= s && e <= r) {
            tree[node].lazy += val;
        }
        else {
            idx_t m = s + e >> 1;
            if (haveOverlap(s, m, l, r)) {
                if(!tree[node].l) tree[node].l = newNode();
                update(tree[node].l, s, m, l, r, val, add);
            }
            if (haveOverlap(m + 1, e, l, r)) {
                if(!tree[node].r) tree[node].r = newNode();
                update(tree[node].r, m + 1, e, l, r, val, add);
            }
            tree[node].val += val * (min(e, r) - max(s, l) + 1);
        }
    }

    T query(int node, idx_t s, idx_t e, idx_t l, idx_t r) {
        if (!node) return tree[0].val; // dummy
        propagate(node, s, e);
        if (r < s || e < l) return 0;
        if (l <= s && e <= r) return tree[node].val;

        idx_t m = s + e >> 1;
        T lq = query(tree[node].l, s, m, l, r);
        T rq = query(tree[node].r, m + 1, e, l, r);
        return merge(lq, rq);
    }

public:
    DynamicLazySeg(idx_t maxIdx) : MAX_IDX(maxIdx), tree(2) {} // tree[0] : dummy, tree[1] : root

    void reserve(int sz) { if (sz > tree.capacity()) tree.reserve(sz); } // array doubling 최소화
    
    void updateAdd(idx_t l, idx_t r, T val) { // 0 <= i <= MAX_IDX
        assert(haveOverlap(0, MAX_IDX, l, r));
        update(root, 0, MAX_IDX, l, r, val, 1);
    }

    void updateAdd(idx_t idx, T val) { // 0 <= i <= MAX_IDX
        assert(haveOverlap(0, MAX_IDX, idx, idx));
        update(root, 0, MAX_IDX, idx, idx, val, 1);
    }

    void updateChange(idx_t l, idx_t r, T val) { // 0 <= i <= MAX_IDX
        update(root, 0, MAX_IDX, l, r, val, 0); // TODO 아직 구현안함
    }

    void updateChange(idx_t idx, T val) { // 0 <= i <= MAX_IDX
        update(root, 0, MAX_IDX, idx, idx, val, 0); // TODO 아직 구현안함
    }

    T query(idx_t l, idx_t r) { // 0 <= l <= r <= MAX_IDX
        return query(root, 0, MAX_IDX, l, r);
    }

// findKth
private:
    idx_t findKthSmallest(int node, idx_t s, idx_t e, T k) {
        if (s == e) return s;
        
        idx_t m = s + e >> 1;
        propagate(tree[node].l, s, m);
        T lsz = tree[tree[node].l].val;
        if (lsz >= k) return findKthSmallest(tree[node].l, s, m, k);
        return findKthSmallest(tree[node].r, m + 1, e, k - lsz);
    }
    
    idx_t findKthLargest(int node, idx_t s, idx_t e, T k) {
        if (s == e) return s;
        
        idx_t m = s + e >> 1;
        propagate(tree[node].r, m + 1, e);
        T rsz = tree[tree[node].r].val;
        if (rsz >= k) return findKthLargest(tree[node].r, m + 1, e, k);
        return findKthLargest(tree[node].l, s, m, k - rsz);
    }

public:
    idx_t findKthSmallest(int k) {
        assert (k >= 1);
        propagate(root, 0, MAX_IDX);
        return k > tree[root].val ? -1 : findKthSmallest(root, 0, MAX_IDX, k);
    }

    idx_t findKthLargest(int k) {
        assert (k >= 1);
        propagate(root, 0, MAX_IDX);
        return k > tree[root].val ? -1 : findKthLargest(root, 0, MAX_IDX, k);
    }
};
```
### 시간복잡도
range update $O(logN)$   
range query $O(logN)$   

### 공간복잡도
$O(QlogN)$   

### 구현 주의사항
> lazy 세그에서 세그이분탐색 할 때 항상 해당되는 내용이긴 한데, `findKth()`안에서 propagate를 할 때 `propagate(node, s, e)`가 아니라 확인하려는 자식에 대해 propagate를 해야 된다.   
근데 이 경우 `propagate(node, s, e)`를 호출하지 않으므로 처음 루트에 lazy가 있다면 전파되지 않기 때문에, `private findKth()`를 호출하기 전 `public findKth()`에서 먼저 `propagate(root)`를 해둬야 한다.   
물론 `private findKth()`함수 안에 `propagate(node, s, e)`를 추가해도 되긴 하지만 이러면 중복으로 propagate()가 호출되는 횟수가 많아져 비효율적이다.
```cpp
private:
    idx_t findKthSmallest(int node, idx_t s, idx_t e, T k) {
        if (s == e) return s;
        
        idx_t m = s + e >> 1;
        propagate(tree[node].l, s, m); // tree[tree[node].r].val 확인하기 전 먼저 propagate
        T lsz = tree[tree[node].l].val;
        if (lsz >= k) return findKthSmallest(tree[node].l, s, m, k);
        return findKthSmallest(tree[node].r, m + 1, e, k - lsz);
    }


public: 
    idx_t findKthSmallest(int k) {
        assert (k >= 1);
        propagate(root, 0, MAX_IDX); // root에 있는 lazy 전파
        return k > tree[root].val ? -1 : findKthSmallest(root, 0, MAX_IDX, k);
    }
```

> `update()`를 구현할 때 애초에 구간이 겹치지 않는다면 노드를 만들지 않아야 된다.   
물론 만들어도 상관없지만 이런 필요없는 노드를 만드는지 아닌지가 메모리 사용량에 정말정말 큰 차이를 만든다. (심한 경우엔 메모리 사용량 2~3배 차이나는 듯)   
```cpp
// 수정 전 코드. 메모리 초과
void update(int node, idx_t s, idx_t e, idx_t l, idx_t r, T val, bool add) {
    propagate(node, s, e);

    if (r < s || e < l) return;
    if (l <= s && e <= r) {
        tree[node].lazy = val;
        return;
    }

    idx_t m = s + e >> 1;
    if(!tree[node].l) tree[node].l = newNode();
    update(tree[node].l, s, m, l, r, val, add);
    if(!tree[node].r) tree[node].r = newNode();
    update(tree[node].r, m + 1, e, l, r, val, add);
    tree[node].val += val * (min(e, r) - max(s, l) + 1);
}

// 수정 후 코드
void update(int node, idx_t s, idx_t e, idx_t l, idx_t r, T val, bool add) {
    propagate(node, s, e);

    // (r < s || e < l)인지 확인 안해도됨. 구간이 아예 안겹치는 경우는 haveOverlap()으로 미리 걸러짐
    // 보기엔 if문 고작 한 개지만 update는 계속 재귀호출되며 여러번 호출되는 함수기에 생각보다 많이 실행되는 코드라서 꽤나 많은 시간을 잡아먹음. 최대한 없앨 수 있는 코드는 없애야 됨
    if (l <= s && e <= r) {
        tree[node].lazy = val;
        return;
    }

    idx_t m = s + e >> 1;
    if (haveOverlap(s, m, l, r)) { // 애초에 구간 겹치지 않는 경우엔 노드를 만들지도 않음
        if(!tree[node].l) tree[node].l = newNode();
        update(tree[node].l, s, m, l, r, val, add);
    }
    if (haveOverlap(m + 1, e, l, r)) {
        if(!tree[node].r) tree[node].r = newNode();
        update(tree[node].r, m + 1, e, l, r, val, add);
    }
    tree[node].val += val * (min(e, r) - max(s, l) + 1);
}
```

### 사용설명
0 <= max_idx 내의 인덱스에 대해서 업데이트 가능   
array doubling 고려해서 reserve()해두고 사용하면 더 좋음   

range update는 update(l, r, val) 사용   
point update는 update(i, val) 사용

### 문제
[일기예보](https://www.acmicpc.net/problem/14577) - 다이나믹 / pUpdate, rQuery / updateAdd / 세그이분탐색   
[나무는 쿼리를 싫어해~](https://www.acmicpc.net/problem/20212) - 다이나믹 레이지 / rUpdate, rQuery / updateAdd   

### 참고링크
https://nicotina04.tistory.com/265   