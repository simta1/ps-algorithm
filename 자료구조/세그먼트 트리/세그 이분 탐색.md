[카테고리](/README.md)
## 세그이분탐색 (Binary Search on SegmentTree)
### findRightMost, findLeftMost([Segment Tree](/자료구조/세그먼트%20트리/세그먼트%20트리.md) 클래스 최하단에 복붙해서 사용)
```cpp
int findRightMost(int l, const function<bool(T)> &f) const { // f([l:r]) = true인 최대의 r을 찾음, l과 r 둘 다 1-based임 // 만족하는 r이 없다면 l-1리턴함
    assert(1 <= l && l <= n);
    T acc = e();
    int node = (l - 1) | sz;
    
    node >>= __builtin_ctz(node); // node[l, r]에서 l은 그대로 두고 r만 최대한 오른쪽으로 이동
    while (f(op(acc, tree[node]))) {
        acc = op(acc, tree[node++]); // f(node[l, r]) 만족하므로 node+1[r+1, ...]로 이동
        if (!(node & (node - 1))) return n; // node++한 게 2^k꼴인거면 이전 node=2^k-1꼴이었던 거라 node[l,r=n]이었던 거
        node >>= __builtin_ctz(node); // node[l, r]에서 l은 그대로 두고 r만 최대한 오른쪽으로 이동
    }
    
    while (node < sz) {
        node <<= 1; // node[l, r] -> node*2[l, m]
        if (f(op(acc, tree[node]))) acc = op(acc, tree[node++]); // [m + 1, r]
    }
    // node[l:r)인 상황인 거라 닫힌 구간 [l, r]꼴로 표현하려면 node-1 리턴해야 해야 되서 (node - 1 - sz)임. 근데 1-based로 바꾸면 아래처럼 됨
    return node ^ sz; // 1-based
}

int findKthSmallest(int l, T k) { // l은 1-based
    return query(l, n) < k ? -1 : 1 + findRightMost(l, [&](T sum) { return sum < k; });
}

// TODO 얘는 테스트 안 해봤음
int findLeftMost(int r, const function<bool(T)> &f) const { // f([l:r]) = true인 최소의 l을 찾음, l과 r 둘 다 1-based임 // 만족하는 l이 없다면 r+1리턴함
    assert(1 <= r && r <= n);
    T acc = e();
    int node = (r - 1) | sz;

    node = max(1, node >> __builtin_ctz(~node)); // node[l, r]에서 r은 그대로 두고 l만 최대한 왼쪽으로 이동, 최대로 이동한 게 루트여야 되므로 0이 되면 1로 바꿔줌
    while (f(op(tree[node], acc))) {
        acc = op(tree[node--], acc);
        if (!((node + 1) & node)) return n; // node--하기 전인 node+1가 2^k꼴인거면 node[l=1,r]이었던 거
        node = max(1, node >> __builtin_ctz(~node));
    }

    while (node < sz) {
        node = node << 1 | 1; // node[l, r] -> node*2+1[m+1,r]
        if (f(op(tree[node], acc))) acc = op(tree[node--], acc);
    }
    
    // node(l:r]인 상황인 거라 닫힌 구간 [l, r]꼴로 표현하려면 node+1 리턴해야 해야 되서 (node + 1 - sz)임. 근데 1-based로 바꾸면 아래처럼 됨
    return node + 2 - sz;
}
```
### 시간복잡도 
$O(\log{N})$   

### 사용설명
findKth, findRightMost, findLeftMost에서 값이 없는 경우 -1 리턴

### 문제
[중앙값 측정](https://www.acmicpc.net/problem/9426) - findKthSmallest   
<!-- [까다로운 아이들과 선물 상자](https://www.acmicpc.net/problem/23760) - findKthLargest
[D. Colored Portals](https://codeforces.com/contest/2004/problem/D) - findLeftMost / findRightMost -->

### 원리
```cpp
int findRightMost(int l, const function<bool(T)> &f) const { // f([l:r]) = true인 최대의 r을 찾음
    assert(1 <= l && l <= n);
    T acc = e();
    int node = (l - 1) | sz;
    // if (!f(tree[node])) return -1; // -1리턴할거면 findKthSmallest에서 +1되는거땜에 좀 이상함..
    
    node >>= __builtin_ctz(node); // node[l, r] -> node[l, max(r)] // 좌측 경계를 유지하며 node를 root쪽으로 최대한 끌어올림
    while (f(op(acc, tree[node]))) {
        acc = op(acc, tree[node++]); // f([l1, r]) 만족하므로 [r+1, ...]구간으로 이동해서 탐색
        if (!(node & (node - 1))) return n; // node++한 게 2^k꼴인거면 이전 node=2^k-1꼴이었던 거라 node[l,r=n]이었던 거
        node >>= __builtin_ctz(node); // 왼쪽 경계는 그대로 두고 오른쪽 경계를 최대한 오른쪽으로 이동 // node[l, r] -> node'[l, max(r')]
    }
    
    while (node < sz) {
        node <<= 1; // node[l, r] -> node'[l, m]
        if (f(op(acc, tree[node]))) acc = op(acc, tree[node++]); // node'[m + 1, r]
    }
    // node[l:r)인 상황임 // node-1[l:r-1]임
    // sz <= node < 2sz
    // 0-based로 (node - 1) - sz 임
    // 1-based는 node - sz가 되고 node>=sz니까 node ^ sz로 가능
    return node ^ sz;
}
```

### 참고링크
https://00ad-8e71-00ff-055d.tistory.com/162

### 예전 코드
<details>
<summary>2025.03.02 이전까지 썼던 재귀함수 코드임, 이젠 버렸지만 뭔가 아까워서 여기 남겨둠</summary>

### findKth
```cpp
private:
    int findKthSmallest(int node, int s, int e, T k) {
        if (s == e) return s + 1; // 1-based
        // if (s == e) return s; // 0-based

        int m = s + e >> 1;
        if (tree[node * 2] >= k) return findKthSmallest(node * 2, s, m, k);
        return findKthSmallest(node * 2 + 1, m + 1, e, k - tree[node * 2]);
    }
    
    int findKthLargest(int node, int s, int e, T k) {
        if (s == e) return s + 1; // 1-based
        // if (s == e) return s; // 0-based

        int m = s + e >> 1;
        if (tree[node * 2 + 1] >= k) return findKthLargest(node * 2 + 1, m + 1, e, k);
        return findKthLargest(node * 2, s, m, k - tree[node * 2 + 1]);
    }

public:
    int findKthSmallest(T k) { // k >= 1
        return k > tree[1] ? -1 : findKthSmallest(1, 0, n - 1, k);
    }

    int findKthLargest(T k) { // k >= 1
        return k > tree[1] ? -1 : findKthLargest(1, 0, n - 1, k);
    }
```

### findLeftMost / findRightMost
```cpp
private:
    int findLeftMost(int node, int s, int e, int l, int r) {
        if (l > e || s > r || tree[node] == 0) return -1;
        if (s == e) return s + 1; // 1-based
 
        int m = s + e >> 1;
        int leftRes = findLeftMost(2 * node, s, m, l, r);
        return ~leftRes ? leftRes : findLeftMost(2 * node + 1, m + 1, e, l, r);
    }
 
    int findRightMost(int node, int s, int e, int l, int r) {
        if (l > e || s > r || tree[node] == 0) return -1;
        if (s == e) return s + 1; // 1-based
 
        int m = s + e >> 1;
        int rightRes = findRightMost(2 * node + 1, m + 1, e, l, r);
        return ~rightRes ? rightRes : findRightMost(2 * node, s, m, l, r);
    }

public:
    int findRightMost(int l, int r) {
        return findRightMost(1, 0, n - 1, l - 1, r - 1);
    }
 
    int findLeftMost(int l, int r) {
        return findLeftMost(1, 0, n - 1, l - 1, r - 1);
    }
```
</details>
